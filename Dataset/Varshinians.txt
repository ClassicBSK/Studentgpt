A queue is a linear collection of data elements in which the element inserted first is the element taken out first (i.e., a queue is a FIFO data structure). A queue is an abstract data structure, somewhat similar to stacks. Unlike stacks, a queue is open on both ends. A queue is a linear data structure in which the first element is inserted on one end, called the REAR end (also called the tail end), and the deletion of the element takes place from the other end, called the FRONT end (also called the head). One end is always used to insert data and the other end is used to remove data.
A queue is a FIFO (First-In, First-Out) data structure in which the element that is inserted first is the first one to be taken out. The elements in a queue are added at one end called the REAR and removed from the other end called the FRONT.
i)Queues are widely used as waiting lists for a single shared resource like printer, disk, CPU. ii)Queues are used to transfer data asynchronously (data not necessarily received at same rate as sent) between two processes (IO buffers), e.g., pipes, file IO, sockets. iii)	Queues are used as buffers on MP3 players and portable CD players, iPod playlist. iv)Queues are used in Playlist for jukebox to add songs to the end, play from the front of the list. v)Queues are used in operating system for handling interrupts. When programming a real-time system that can be interrupted, for example, by a mouse click, it is necessary to process the interrupts immediately, before proceeding with the current job. If the interrupts have to be handled in the order of arrival, then a FIFO queue is the appropriate data structure. 
Queues can be easily implemented using arrays. Initially, the front end (head) and the rear end (tail) of the queue point at the first position or location of the array. As we insert new elements into the queue, the rear keeps on incrementing, always pointing to the position where the next element will be inserted, while the front remains in the first position. Queues can also be implemented using linked lists, dynamic memory allocation takes place; that is, the memory is allocated at runtime. But in the case of arrays, memory is allocated at the start of the program. If we are aware of the maximum size of the queue in advance, then the implementation of a queue using arrays is efficient. But if the size is not known in advance, then we use the concept of a linked list, in which dynamic memory allocation takes place. A linked list has two parts: the first part contains the information of the node, Queues and the second part stores the address of the next element in the linked list.
We check for underflow conditions. An underflow condition occurs when we try to delete an element from a queue that is already empty. If FRONT = –1 and REAR = –1, it means there is no element in the queue that is, the queue is empty.
Let’s assume, FRONT = 0 and REAR = 5. Suppose we want to add another element with value 45, then REAR would be incremented by 1 and the value would be stored at the position pointed by REAR. Now the queue will become, FRONT = 0 and REAR = 6. However, before inserting an element in a queue, we must check for overflow conditions. An overflow will occur when we try to insert an element into a queue that is already full. When REAR = MAX – 1, where MAX is the size of the queue, we have an overflow condition.
If we want to delete an element from the queue, then the value of FRONT will be incremented. Deletions are done from only this end of the queue. Before deleting an element from a queue, we must check for underflow conditions. An underflow condition occurs when we try to delete an element from a queue that is already empty. If FRONT = –1 and REAR = –1, it means there is no element in the queue.
A queue can be created using an array. Although this technique of creating a queue is easy, its drawback is that the array must be declared to have some fixed size. If we allocate space for 50 elements in the queue and it hardly uses 20–25 locations, then half of the space will be wasted. And in case we allocate less memory locations for a queue that might end up growing large and large, then a lot of re-allocations will have to be done, thereby creating a lot of overhead and consuming a lot of time. In a linked queue, every element has two parts, one that stores the data and another that stores the address of the next element. The START pointer of the linked list is used as FRONT. Here, we will also use another pointer called REAR, which will store the address of the last element in the queue. All insertions will be done at the rear end and all the deletions will be done at the front end.
A deque (pronounced as ‘deck’ or ‘dequeue’) is a list in which the elements can be inserted or deleted at either end. It is also known as a head-tail linked list because elements can be added to or removed from either the front (head) or the back (tail) end. However, no element can be added and deleted from the middle. In the computer’s memory, a deque is implemented using either a circular array or a circular doubly linked list. In a deque, two pointers are maintained, LEFT and RIGHT, which point to either end of the deque.
A priority queue is a data structure in which each element is assigned a priority. The priority of the element will be used to determine the order in which the elements will be processed. The general rules of processing the elements of a priority queue are o	An element with higher priority is processed before an element with a lower priority.  o	Two elements with the same priority are processed on a first-come-first-served (FCFS) basis.
A priority queue can be implemented using a linked list. When implementing the priority queue using a linked list, every node has three parts: a. Information part b. Priority number of the element c. Address of the next element. An element with higher priority precedes the element having a lower priority. Also, the priority number and priority are opposite to each other; that is, an element having a lower priority number means it has higher priority. For example, if there are two elements, X and Y, with priority numbers 2 and 7, respectively, then X will be processed first because it has a higher priority.
A circular queue is a special type of queue implemented in a circular fashion rather than in a straight line. A circular queue is a linear data structure in which the operations are performed based on the FIFO principle and the last position is connected to the first position to make a circle. It is also called a “ring buffer.”
In a circular queue, the elements are stored in a circular form such that the first element is next to the last element in the queue. A circular queue will be full when FRONT = 0 and REAR = MAX – 1 or FRONT = REAR + 1. . In that case, an overflow error message will be displayed on the screen. Similarly, a circular queue is empty when both FRONT and REAR are equal to zero. In that case, an underflow error message is displayed on the screen.
